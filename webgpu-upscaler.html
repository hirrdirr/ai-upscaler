<!doctype html>
<html lang="sv">
<head>
  <meta charset="utf-8" />
  <title>AI Upscaler – WebGPU/ONNX prototyp</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #111;
      color: #eee;
      margin: 0;
      padding: 20px;
      box-sizing: border-box;
    }
    .card {
      max-width: 900px;
      margin: 0 auto;
      background: #181818;
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 10px 25px rgba(0,0,0,0.5);
      border: 1px solid #333;
    }
    h1 { margin: 0 0 10px 0; font-size: 1.6rem; }
    .subtitle { font-size: 0.9rem; color: #bbb; margin-bottom: 16px; }
    .controls { display:flex; flex-wrap:wrap; gap:12px; align-items:center; margin-bottom:12px; }
    button {
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      background: #3b82f6;
      color: white;
      font-weight: 600;
      cursor: pointer;
    }
    button:disabled { opacity: .5; cursor: default; }
    #status { font-size: 0.9rem; margin: 8px 0 8px 0; color: #aaa; }

    #progressContainer {
      width: 100%;
      background: #222;
      border-radius: 6px;
      overflow: hidden;
      height: 12px;
      display: none;
      margin-bottom: 12px;
    }
    #progressBar {
      width: 0%;
      height: 100%;
      background: linear-gradient(90deg, #3b82f6, #60a5fa);
      transition: width 0.25s ease-out;
    }

    .preview-wrapper {
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(260px,1fr));
      gap:16px;
      margin-top:10px;
    }
    .preview {
      background:#101010;
      border-radius:8px;
      padding:10px;
      border:1px solid #222;
    }
    .preview h2 { margin:0 0 8px 0; font-size:1rem; }
    .preview img { max-width:100%; height:auto; border-radius:6px; background:black; }
    .dims { margin-top:6px; font-size:0.8rem; color:#999; font-family:"JetBrains Mono","Fira Code",monospace; }
  </style>
</head>
<body>
  <div class="card">
    <h1>AI Upscaler – WebGPU prototyp</h1>
    <p class="subtitle">
      Kör ONNX-modell direkt i webbläsaren via WebGPU (med fallback till WASM).
      <br/>
      <b>OBS:</b> Du behöver lägga din modell som <code>models/sr.onnx</code>.
    </p>

    <div class="controls">
      <input type="file" id="fileInput" accept="image/*" />
      <button id="runBtn" disabled>Upscale (4x ONNX)</button>
    </div>

    <div id="status">Initierar...</div>

    <div id="progressContainer"><div id="progressBar"></div></div>

    <div class="preview-wrapper">
      <div class="preview">
        <h2>Original</h2>
        <img id="origImg" />
        <p class="dims" id="origDims">–</p>
      </div>
      <div class="preview">
        <h2>Upscalad (WebGPU)</h2>
        <img id="upImg" />
        <p class="dims" id="upDims">–</p>
      </div>
    </div>
  </div>

  <!-- ONNX Runtime Web, WebGPU build -->
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.webgpu.min.js"></script>

  <script>
    const fileInput = document.getElementById('fileInput');
    const runBtn = document.getElementById('runBtn');
    const statusEl = document.getElementById('status');
    const origImg = document.getElementById('origImg');
    const upImg   = document.getElementById('upImg');
    const origDims = document.getElementById('origDims');
    const upDims   = document.getElementById('upDims');
    const progressContainer = document.getElementById('progressContainer');
    const progressBar = document.getElementById('progressBar');

    // === KONFIG ===
    const MODEL_URL = 'models/sr.onnx'; // <-- hit lägger du din ONNX-modell (t.ex. RealESRGAN/SwinIR 4x)

    let session = null;

    function checkWebGPU() {
      if (!('gpu' in navigator)) {
        statusEl.textContent = 'WebGPU saknas i denna webbläsare. ONNX körs då via WASM (långsammare).';
        return false;
      }
      return true;
    }

    function formatDims(w,h) {
      if (!w || !h) return '–';
      return `${w} × ${h} px`;
    }

    function startProgress(msg) {
      statusEl.textContent = msg;
      progressContainer.style.display = 'block';
      progressBar.style.width = '5%';
    }
    function setProgress(p) {
      progressBar.style.width = `${p}%`;
    }
    function endProgress(msg) {
      progressBar.style.width = '100%';
      statusEl.textContent = msg;
      setTimeout(() => {
        progressContainer.style.display = 'none';
        progressBar.style.width = '0%';
      }, 600);
    }

    async function initSession() {
      try {
        const hasWebGPU = checkWebGPU();
        // lite info
        if (hasWebGPU) {
          statusEl.textContent = 'Laddar ONNX-modell med WebGPU...';
        } else {
          statusEl.textContent = 'Laddar ONNX-modell (WASM fallback)...';
        }

        // WebGPU + WASM fallback
        session = await ort.InferenceSession.create(MODEL_URL, {
          executionProviders: hasWebGPU ? ['webgpu','wasm'] : ['wasm'],
        });

        statusEl.textContent = 'Modell klar. Ladda upp en bild.';
        runBtn.disabled = false;
      } catch (e) {
        console.error(e);
        statusEl.textContent = 'Kunde inte ladda ONNX-modellen. Kontrollera sökväg och CORS.';
      }
    }

    // Ladda modell direkt vid sidstart
    window.addEventListener('load', initSession);

    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = ev => {
        origImg.src = ev.target.result;
        upImg.src = '';
        upDims.textContent = '–';
        origImg.onload = () => {
          origDims.textContent = formatDims(origImg.naturalWidth, origImg.naturalHeight);
        };
      };
      reader.readAsDataURL(file);
    });

    async function imageToTensor4x(img) {
      // Exempel: model förväntar sig [1,3,H,W] float32, värden 0–1
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = img.naturalWidth;
      canvas.height = img.naturalHeight;
      ctx.drawImage(img, 0, 0);
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const { data, width, height } = imageData;

      const floatData = new Float32Array(3 * width * height);
      // RGBA → CHW
      for (let i = 0; i < width * height; i++) {
        const r = data[i * 4]     / 255;
        const g = data[i * 4 + 1] / 255;
        const b = data[i * 4 + 2] / 255;
        floatData[i]                 = r;
        floatData[i + width*height]  = g;
        floatData[i + 2*width*height]= b;
      }

      const tensor = new ort.Tensor('float32', floatData, [1, 3, height, width]);
      return { tensor, width, height };
    }

    function tensorToImageData(tensor, scale) {
      // tensor: [1,3,H,W] float32 0–1
      const [n,c,h,w] = tensor.dims;
      const data = tensor.data;
      const canvas = document.createElement('canvas');
      canvas.width = w;
      canvas.height = h;
      const ctx = canvas.getContext('2d');
      const imgData = ctx.createImageData(w, h);
      const out = imgData.data;

      const planeSize = w*h;
      for (let i = 0; i < planeSize; i++) {
        const r = data[i] * 255;
        const g = data[i + planeSize] * 255;
        const b = data[i + 2*planeSize] * 255;
        out[i*4]   = Math.max(0, Math.min(255, r));
        out[i*4+1] = Math.max(0, Math.min(255, g));
        out[i*4+2] = Math.max(0, Math.min(255, b));
        out[i*4+3] = 255;
      }
      ctx.putImageData(imgData, 0, 0);
      return canvas.toDataURL('image/png');
    }

    runBtn.addEventListener('click', async () => {
      if (!session) {
        alert('Modellen är inte laddad ännu.');
        return;
      }
      if (!origImg.src) {
        alert('Ladda upp en bild först.');
        return;
      }

      try {
        startProgress('Förbereder bild...');

        const { tensor } = await imageToTensor4x(origImg);

        setProgress(30);
        statusEl.textContent = 'Kör ONNX-modellen...';

        // OBS: namn på input/output beror på modellen!
        // Vanligt i exempelsr: "input" / "output" eller liknande.
        const feeds = { input: tensor };
        const results = await session.run(feeds);

        setProgress(75);
        const outputName = Object.keys(results)[0];
        const outputTensor = results[outputName];

        const dataUrl = tensorToImageData(outputTensor);

        upImg.src = dataUrl;
        upImg.onload = () => {
          upDims.textContent = formatDims(upImg.naturalWidth, upImg.naturalHeight);
        };

        endProgress('Klar (ONNX/WebGPU).');

      } catch (e) {
        console.error(e);
        statusEl.textContent = 'Fel vid inferens. Kolla konsolen.';
        progressContainer.style.display = 'none';
      }
    });
  </script>
</body>
</html>
